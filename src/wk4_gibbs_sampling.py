#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""

GibbsSampler randomly selects an integer i between 0 and t-1 and then randomly changes a single k-mer Motif[i].
That is, GibbsSampler makes two random choices at each iteration. It uses random.randint(0, t-1) for the first choice
(since all t strings in Dna are equally likely), but it does not make sense to use random.randint to choose a k-mer
from Motif[i] because some k-mers are more likely than others.

Indeed, each k-mer Pattern in Motif[i] may have a different probability Pr(Pattern, Profile) that it was
generated by Profile.


1) randomly selected a string for removal. To be more precise, GibbsSampler does not really remove the third string;
it ignores it at this particular step and may analyze it again in subsequent steps.

2) compute a profile matrix from the selected strings

3) use this profile matrix to compute the probabilities of all 4-mers in the deleted string

   Note: as before, we need to augment zero probabilities with small pseudocounts:
         >> add +1 to each element in Count matrix first!

Note that in contrast to RandomizedMotifSearch, which always moves from higher to lower scoring Motifs,
GibbsSampler may move from lower to higher scoring Motifs. Does this make sense?

>> Although GibbsSampler performs well in many cases, it may converge to a suboptimal solution, particularly for
difficult search problems with elusive motifs.


GibbsSampler explores just a small subset of solutions, it may “get stuck” in a local optimum. For this reason,
similarly to RandomizedMotifSearch, it should be run many times with the hope that one of these runs will produce the
best-scoring motifs. Yet convergence to a local optimum is just one of many issues we must consider in motif finding;
see https://stepik.org/lesson/Detour-Complications-in-Motif-Finding-24210


"""
import random

def Normalize(Probabilities):
    norm_p = {}
    total = sum(Probabilities.values())
    for k, v in Probabilities.items():
        norm_p[k] = v / total
    return norm_p


def WeightedDie(Probabilities):
    kmer = ''  # output variable
    r = random.uniform(0, 1)
    start = 0
    for key, value in [(k, Probabilities[k]) for k in sorted(Probabilities,
                                                 key=Probabilities.get,
                                                 reverse=False)]:
        value = value + start
        # print('\nkey {} | start {} | value {} | r {} | kmer {}'.format(key, start, value, r, kmer))

        if start <= r <= value:
            kmer = key
            return kmer
        start = value

def Pr(Text, profile):
    p = 1
    pos = 0 # init pos
    for i in Text:
        p *= profile[i][pos]
        # move one position to the right
        pos += 1
    return p

def ProfileGeneratedString(Text, profile, k):
    """
    :param Text:
    :param profile:
    :param k:
    :return: a randomly generated k-mer from Text whose probabilities are generated from profile,

    e.g. randomly generated 4-mer GCGT = the fourth 4-mer in the "deleted" string
    """
    n = len(Text)
    probabilities = {}
    for i in range(0, n - k + 1):
        probabilities[Text[i:i + k]] = Pr(Text[i:i + k], profile)
    probabilities = Normalize(probabilities)
    return WeightedDie(probabilities)

def RandomMotifs(Dna, k, t):
    """Important Note: an independent random starting position should be generated for each Dna string"""
    m = len(Dna[0])
    # print('\nm: {} k: {} m-k+1:{}'.format(m,k, m-k))

    random_motifs = []
    for i in range(t):
        r = random.randint(1, m - k)
        # print(r)
        # if r > m - k :
        #     r = r - k
        #     print('  {}'.format(r+k))
        # print(Dna[i][r:r+k])

        random_motifs.append(Dna[i][r:r + k])
    return random_motifs

def Count(Motifs):
    countMatrix = {}
    k = len(Motifs[0])
    # print(Motifs)
    # init dict of lists (one list for each DNA base)
    for symbol in "ACGT":
        countMatrix[symbol] = []
        for j in range(k):
            countMatrix[symbol].append(1.0)
    # populate dict of lists
    t = len(Motifs)
    for i in range(t):
        for j in range(k):
            symbol = Motifs[i][j]
            countMatrix[symbol][j] += 1
    return countMatrix

def ProfileWithPseudocounts(Motifs):
    t = len(Motifs)

    profileMatrix = Count(Motifs=Motifs)
    for k, v in profileMatrix.items():
        v[:] = [i / t + 4 for i in v] # +4 to account for initialzing count matrix with 1's
    return profileMatrix

def most_probable_kmer(text, k, profile):
    n = len(text)
    most_probable = {}
    for i in range(n - k + 1):
        pattern = text[i:i + k]
        most_probable[pattern] = Pr(pattern, profile)
    return max(most_probable, key=most_probable.get)


def Consensus(Motifs):
    k = len(Motifs[0])
    count_matrix = Count(Motifs)
    consensus = ""
    for i in range(k):
        m = 0
        frequentSymbol = ""
        for symbol in "ACGT":
            if count_matrix[symbol][i] > m:
                m = count_matrix[symbol][i]
                frequentSymbol = symbol
        consensus += frequentSymbol
    return consensus


def Motifs(Profile, Dna):
    k = len(Profile['A'])
    motifs = []
    for i in range(len(Dna)):
        motifs.append(most_probable_kmer(Dna[i], k, Profile))
    return motifs


def Score(Motifs):
    # my approach
    # score = 0
    # consensus = Consensus(Motifs=Motifs)
    # motifs_by_col = [''.join(x) for x in zip(*Motifs)]
    # n = len(motifs_by_col)
    # for i in range(n):
    #     #score = sum the number of symbols in the j-th column of Motifs that do not match
    #     count = [1 for x in motifs_by_col[i] if not x == consensus[i]]
    #     score += sum(count) * (1 / n ** 4)  # multiply by (1/n**4) to account for intializing the count matrix with ones
    # return score

    # Jorge Iván Fuentes Rosado
    score = 0
    consensus = Consensus(Motifs)
    for row in Motifs:
        for c1, r1 in zip(consensus, row):
            if c1 != r1:
                score += 1
    return score


def GibbsSampler(Dna, k, t, N):
    M = RandomMotifs(Dna, k, t)
    # print('\n{}'.format(M))
    BestMotifs = M

    for j in range(1, N):
        r = random.randint(0, t-1)
        # print(r)
        Mcopy = M.copy() # https://stackoverflow.com/questions/35428994/remove-row-from-matrix-in-python
        del Mcopy[r]
        Profile = ProfileWithPseudocounts(Mcopy)
        Mi = ProfileGeneratedString(Dna[r], Profile, k)
        M = Motifs(Profile, Dna)
        M[r] = Mi
        # print(M)

        if Score(M) < Score(BestMotifs):
            BestMotifs = M
        else:
            return BestMotifs


Dna = ["GCGCCCCGCCCGGACAGCCATGCGCTAACCCTGGCTTCGATGGCGCCGGCTCAGTTAGGGCCGGAAGTCCCCAATGTGGCAGACCTTTCGCCCCTGGCGGACGAATGACCCCAGTGGCCGGGACTTCAGGCCCTATCGGAGGGCTCCGGCGCGGTGGTCGGATTTGTCTGTGGAGGTTACACCCCAATCGCAAGGATGCATTATGACCAGCGAGCTGAGCCTGGTCGCCACTGGAAAGGGGAGCAACATC",
"CCGATCGGCATCACTATCGGTCCTGCGGCCGCCCATAGCGCTATATCCGGCTGGTGAAATCAATTGACAACCTTCGACTTTGAGGTGGCCTACGGCGAGGACAAGCCAGGCAAGCCAGCTGCCTCAACGCGCGCCAGTACGGGTCCATCGACCCGCGGCCCACGGGTCAAACGACCCTAGTGTTCGCTACGACGTGGTCGTACCTTCGGCAGCAGATCAGCAATAGCACCCCGACTCGAGGAGGATCCCG",
"ACCGTCGATGTGCCCGGTCGCGCCGCGTCCACCTCGGTCATCGACCCCACGATGAGGACGCCATCGGCCGCGACCAAGCCCCGTGAAACTCTGACGGCGTGCTGGCCGGGCTGCGGCACCTGATCACCTTAGGGCACTTGGGCCACCACAACGGGCCGCCGGTCTCGACAGTGGCCACCACCACACAGGTGACTTCCGGCGGGACGTAAGTCCCTAACGCGTCGTTCCGCACGCGGTTAGCTTTGCTGCC",
"GGGTCAGGTATATTTATCGCACACTTGGGCACATGACACACAAGCGCCAGAATCCCGGACCGAACCGAGCACCGTGGGTGGGCAGCCTCCATACAGCGATGACCTGATCGATCATCGGCCAGGGCGCCGGGCTTCCAACCGTGGCCGTCTCAGTACCCAGCCTCATTGACCCTTCGACGCATCCACTGCGCGTAAGTCGGCTCAACCCTTTCAAACCGCTGGATTACCGACCGCAGAAAGGGGGCAGGAC",
"GTAGGTCAAACCGGGTGTACATACCCGCTCAATCGCCCAGCACTTCGGGCAGATCACCGGGTTTCCCCGGTATCACCAATACTGCCACCAAACACAGCAGGCGGGAAGGGGCGAAAGTCCCTTATCCGACAATAAAACTTCGCTTGTTCGACGCCCGGTTCACCCGATATGCACGGCGCCCAGCCATTCGTGACCGACGTCCCCAGCCCCAAGGCCGAACGACCCTAGGAGCCACGAGCAATTCACAGCG",
"CCGCTGGCGACGCTGTTCGCCGGCAGCGTGCGTGACGACTTCGAGCTGCCCGACTACACCTGGTGACCACCGCCGACGGGCACCTCTCCGCCAGGTAGGCACGGTTTGTCGCCGGCAATGTGACCTTTGGGCGCGGTCTTGAGGACCTTCGGCCCCACCCACGAGGCCGCCGCCGGCCGATCGTATGACGTGCAATGTACGCCATAGGGTGCGTGTTACGGCGATTACCTGAAGGCGGCGGTGGTCCGGA",
"GGCCAACTGCACCGCGCTCTTGATGACATCGGTGGTCACCATGGTGTCCGGCATGATCAACCTCCGCTGTTCGATATCACCCCGATCTTTCTGAACGGCGGTTGGCAGACAACAGGGTCAATGGTCCCCAAGTGGATCACCGACGGGCGCGGACAAATGGCCCGCGCTTCGGGGACTTCTGTCCCTAGCCCTGGCCACGATGGGCTGGTCGGATCAAAGGCATCCGTTTCCATCGATTAGGAGGCATCAA",
"GTACATGTCCAGAGCGAGCCTCAGCTTCTGCGCAGCGACGGAAACTGCCACACTCAAAGCCTACTGGGCGCACGTGTGGCAACGAGTCGATCCACACGAAATGCCGCCGTTGGGCCGCGGACTAGCCGAATTTTCCGGGTGGTGACACAGCCCACATTTGGCATGGGACTTTCGGCCCTGTCCGCGTCCGTGTCGGCCAGACAAGCTTTGGGCATTGGCCACAATCGGGCCACAATCGAAAGCCGAGCAG",
"GGCAGCTGTCGGCAACTGTAAGCCATTTCTGGGACTTTGCTGTGAAAAGCTGGGCGATGGTTGTGGACCTGGACGAGCCACCCGTGCGATAGGTGAGATTCATTCTCGCCCTGACGGGTTGCGTCTGTCATCGGTCGATAAGGACTAACGGCCCTCAGGTGGGGACCAACGCCCCTGGGAGATAGCGGTCCCCGCCAGTAACGTACCGCTGAACCGACGGGATGTATCCGCCCCAGCGAAGGAGACGGCG",
"TCAGCACCATGACCGCCTGGCCACCAATCGCCCGTAACAAGCGGGACGTCCGCGACGACGCGTGCGCTAGCGCCGTGGCGGTGACAACGACCAGATATGGTCCGAGCACGCGGGCGAACCTCGTGTTCTGGCCTCGGCCAGTTGTGTAGAGCTCATCGCTGTCATCGAGCGATATCCGACCACTGATCCAAGTCGGGGGCTCTGGGGACCGAAGTCCCCGGGCTCGGAGCTATCGGACCTCACGATCACC"]

t = 10  # nbr of string
k = 15
N = 100
batches = 20


BestMotifs_Iter = []
for i in range(20):
    BestMotifs_Iter.append(GibbsSampler(Dna=Dna, k=k, t=t, N=N))
# print(BestMotifs_Iter)
best_score = 100
best_motifs = []
for motifs in BestMotifs_Iter:
    # print(motifs)
    score = Score(motifs)
    # print(score)
    if score < best_score:
        best_score = score
        best_motifs = motifs
print(best_motifs)
print(best_score)