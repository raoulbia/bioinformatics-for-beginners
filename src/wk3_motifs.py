#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import random

def get_count_matrix(Motifs):
    """
    get the counts of each of the DNA bases
    note that the count matrix has four rows and len(motifs) nbr of columns
    """

    countMatrix = {}
    k = len(Motifs[0])

    # init dict of lists (one list for each DNA base)
    for symbol in "ACGT":
        countMatrix[symbol] = []
        for j in range(k):
            countMatrix[symbol].append(1)

    # populate dict of lists
    t = len(Motifs)
    for i in range(t):
        for j in range(k):
            symbol = Motifs[i][j]
            countMatrix[symbol][j] += 1
    return countMatrix


def get_profile_matrix(Motifs):
    """
    is the same as the get_count_matrix with all elements divided by total nbr of motifs

    element (i,j) is the frequency of the i-th nucleotide in the j-th column of the motif matrix
    i.e., the number of occurrences of the i-th nucleotide divided by the number of nucleotides
    in the column (resp. the nbr of motifs)

    Note that the elements of any column of the profile matrix sum to 1.

    subroutine: get_count_matrix

    NOTE
    By definition, we divide each element of our matrix by the sum of its column
    (so that each column results in a sum of 1). Before, the sum total of any given column
    was len(Motifs). Now, however, because we add an extra +1 for each letter {A,C,G,T},
    we add 4 to each column's total via pseudocounts. Therefore, the sum total of each column
    (i.e., the number we need to divide by in order to create our profile matrix) is t+4 instead of t
    (where tï»¿ is len(Motifs))
    """
    t = len(Motifs)

    profileMatrix = get_count_matrix(Motifs=Motifs)
    for k, v in profileMatrix.items():
        v[:] = [i / t + 4 for i in v]
    return profileMatrix


def get_consensus_motif(Motifs):
    """
    a consensus motif is formed from the most frequently occurring nucleotides in each column
    of the motif matrix (ties are broken arbitrarily).

    If we select Motifs correctly from the collection of upstream regions,
    then the corresponding consensus motif provides a candidate regulatory motif for these regions

    subroutine: get_count_matrix
    """
    k = len(Motifs[0])

    count_matrix = get_count_matrix(Motifs)
    consensus = ""
    for i in range(k):
        m = 0
        frequentSymbol = ""
        for symbol in "ACGT":
            if count_matrix[symbol][i] > m:
                m = count_matrix[symbol][i]
                frequentSymbol = symbol
        consensus += frequentSymbol
    return consensus


def Score(Motifs):
    """
    score = sum sum the number of symbols in the j-th column of Motifs that do not match
    the symbol in position j of the consensus string

    subroutines: get_consensus_motifs (which needs get_count_matrix)
    """
    score = 0
    consensus = get_consensus_motif(Motifs=Motifs)

    """
    for each character at postion j in the consensus motif we need to perform a count operation
    in the corresponding column j of the motifs matrix

    to do so we 'transpose' the input lists such as to create lists consisting of only
    the elements of the ith column of each input motif list
    e.g. motifs_by_col[0] consists of motifs[0][0], motifs[1][0], motifs[2][0] ...

    in this way it is then easy  to count the nbr of elemets that do not match
    the symbol in position j of the consensus string
    """
    motifs_by_col = [''.join(x) for x in zip(*Motifs)]
    n = len(motifs_by_col)
    for i in range(n):
        count = [1 for x in motifs_by_col[i] if not x == consensus[i]]
        score += sum(count) * (1/n**4) # multiply by (1/n**4) to account for intializing the count matrix with ones
    return score


def get_string_probability_from_profile_matrix(Text, profile):
    """
    returns the probability that a profile matrix will produce a given string

    the probability is given by the product of individual nucleotide probabilities.

    subroutine: None
    """
    p = 1
    pos = 0 # init pos
    for i in Text:
        p *= profile[i][pos]
        # move one position to the right
        pos += 1
    return p


def get_most_probable_kmer_from_profile_matrix(text, k, profile):
    """
    Given a profile matrix, we can compute the probability of every k-mer in a text string
    and find the "most probable" k-mer in this text

    i.e. the k-mer that, among all possible k-mers in the text, is most likely
    to have been generated by the profile matrix

    recall that the profile matrix represents the frequency of occurrence
    of each DNA base of the input text in the corresponding column of the motifs matrix

    applies sliding k-window across input text
    at each slide, gets probaility for cuurrent window and stores it
    at the end the max proba is used to select the most probable k-mer

    subroutine: get_string_probability_from_profile_matrix
    """
    n = len(text)
    most_probable = {}
    for i in range(n - k + 1):
        pattern = text[i:i + k]
        most_probable[pattern] = get_string_probability_from_profile_matrix(pattern, profile)
    return max(most_probable, key=most_probable.get)


def get_kmer_motifs(Profile, Dna):
    k = len(Profile['A'])
    motifs = []
    for i in range(len(Dna)):
        motifs.append(get_most_probable_kmer_from_profile_matrix(Dna[i], k, Profile))
    return motifs

def get_random_motifs(Dna, k, t):
    """Important Note:
       an independent random starting position should be generated for each line in Dna
    """
    m = len(Dna[0])
    # print('\nm: {} k: {} m-k+1:{}'.format(m,k, m-k))

    random_motifs = []
    for i in range(t):
        r = random.randint(1, m)
        # print(r)
        if r > m - k :
            r = r - k
            # print('  {}'.format(r+k))

        random_motifs.append(Dna[i][r:r+k])
    return random_motifs


def GreedyMotifSearch(Dna, k, nbr_strings):
    BestMotifs = []
    for i in range(0, nbr_strings):
        BestMotifs.append(Dna[i][0:k])
    # print(BestMotifs)
    n = len(Dna[0])
    for i in range(n - k + 1):
        Motifs = []
        Motifs.append(Dna[0][i:i + k])
        for j in range(1, nbr_strings):
            P = get_profile_matrix(Motifs[0:j])
            Motifs.append(get_most_probable_kmer_from_profile_matrix(Dna[j], k, P))
        if Score(Motifs) < Score(BestMotifs):
            BestMotifs = Motifs
    return BestMotifs


def RandomizedMotifSearch(Dna, k, t):
    M = get_random_motifs(Dna, k, t)
    BestMotifs = M

    while True:
        Profile = get_profile_matrix(M)
        M = get_kmer_motifs(Profile, Dna)
        if Score(M) < Score(BestMotifs):
            BestMotifs = M
        else:
            return BestMotifs